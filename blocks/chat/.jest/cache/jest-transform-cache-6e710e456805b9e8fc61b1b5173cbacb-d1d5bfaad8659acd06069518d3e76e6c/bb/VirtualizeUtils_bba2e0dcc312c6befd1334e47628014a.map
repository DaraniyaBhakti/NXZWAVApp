{"version":3,"names":["_interopRequireDefault","require","_slicedToArray2","invariant","elementsThatOverlapOffsets","offsets","itemCount","getFrameMetrics","out","outLength","ii","frame","trailingOffset","offset","length","kk","JSON","stringify","newRangeCount","prev","next","last","first","Math","max","min","computeWindowedRenderLimits","props","getFrameMetricsApprox","scrollMetrics","data","getItemCount","maxToRenderPerBatch","windowSize","velocity","visibleLength","visibleBegin","visibleEnd","overscanLength","leadFactor","fillPreference","overscanBegin","overscanEnd","lastItemOffset","_elementsThatOverlapO","_elementsThatOverlapO2","default","overscanFirst","overscanLast","visible","newCellCount","maxNewCells","firstWillAddMore","firstShouldIncrement","lastWillAddMore","lastShouldIncrement","Error","VirtualizeUtils","module","exports"],"sources":["VirtualizeUtils.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n'use strict';\n\nconst invariant = require('invariant');\n\n/**\n * Used to find the indices of the frames that overlap the given offsets. Useful for finding the\n * items that bound different windows of content, such as the visible area or the buffered overscan\n * area.\n */\nfunction elementsThatOverlapOffsets(\n  offsets: Array<number>,\n  itemCount: number,\n  getFrameMetrics: (index: number) => {length: number, offset: number},\n): Array<number> {\n  const out = [];\n  let outLength = 0;\n  for (let ii = 0; ii < itemCount; ii++) {\n    const frame = getFrameMetrics(ii);\n    const trailingOffset = frame.offset + frame.length;\n    for (let kk = 0; kk < offsets.length; kk++) {\n      if (out[kk] == null && trailingOffset >= offsets[kk]) {\n        out[kk] = ii;\n        outLength++;\n        if (kk === offsets.length - 1) {\n          invariant(\n            outLength === offsets.length,\n            'bad offsets input, should be in increasing order: %s',\n            JSON.stringify(offsets),\n          );\n          return out;\n        }\n      }\n    }\n  }\n  return out;\n}\n\n/**\n * Computes the number of elements in the `next` range that are new compared to the `prev` range.\n * Handy for calculating how many new items will be rendered when the render window changes so we\n * can restrict the number of new items render at once so that content can appear on the screen\n * faster.\n */\nfunction newRangeCount(\n  prev: {first: number, last: number},\n  next: {first: number, last: number},\n): number {\n  return (\n    next.last -\n    next.first +\n    1 -\n    Math.max(\n      0,\n      1 + Math.min(next.last, prev.last) - Math.max(next.first, prev.first),\n    )\n  );\n}\n\n/**\n * Custom logic for determining which items should be rendered given the current frame and scroll\n * metrics, as well as the previous render state. The algorithm may evolve over time, but generally\n * prioritizes the visible area first, then expands that with overscan regions ahead and behind,\n * biased in the direction of scroll.\n */\nfunction computeWindowedRenderLimits(\n  props: {\n    data: any,\n    getItemCount: (data: any) => number,\n    maxToRenderPerBatch: number,\n    windowSize: number,\n  },\n  prev: {first: number, last: number},\n  getFrameMetricsApprox: (index: number) => {length: number, offset: number},\n  scrollMetrics: {\n    dt: number,\n    offset: number,\n    velocity: number,\n    visibleLength: number,\n  },\n): {first: number, last: number} {\n  const {data, getItemCount, maxToRenderPerBatch, windowSize} = props;\n  const itemCount = getItemCount(data);\n  if (itemCount === 0) {\n    return prev;\n  }\n  const {offset, velocity, visibleLength} = scrollMetrics;\n\n  // Start with visible area, then compute maximum overscan region by expanding from there, biased\n  // in the direction of scroll. Total overscan area is capped, which should cap memory consumption\n  // too.\n  const visibleBegin = Math.max(0, offset);\n  const visibleEnd = visibleBegin + visibleLength;\n  const overscanLength = (windowSize - 1) * visibleLength;\n\n  // Considering velocity seems to introduce more churn than it's worth.\n  const leadFactor = 0.5; // Math.max(0, Math.min(1, velocity / 25 + 0.5));\n\n  const fillPreference =\n    velocity > 1 ? 'after' : velocity < -1 ? 'before' : 'none';\n\n  const overscanBegin = Math.max(\n    0,\n    visibleBegin - (1 - leadFactor) * overscanLength,\n  );\n  const overscanEnd = Math.max(0, visibleEnd + leadFactor * overscanLength);\n\n  const lastItemOffset = getFrameMetricsApprox(itemCount - 1).offset;\n  if (lastItemOffset < overscanBegin) {\n    // Entire list is before our overscan window\n    return {\n      first: Math.max(0, itemCount - 1 - maxToRenderPerBatch),\n      last: itemCount - 1,\n    };\n  }\n\n  // Find the indices that correspond to the items at the render boundaries we're targeting.\n  let [overscanFirst, first, last, overscanLast] = elementsThatOverlapOffsets(\n    [overscanBegin, visibleBegin, visibleEnd, overscanEnd],\n    props.getItemCount(props.data),\n    getFrameMetricsApprox,\n  );\n  overscanFirst = overscanFirst == null ? 0 : overscanFirst;\n  first = first == null ? Math.max(0, overscanFirst) : first;\n  overscanLast = overscanLast == null ? itemCount - 1 : overscanLast;\n  last =\n    last == null\n      ? Math.min(overscanLast, first + maxToRenderPerBatch - 1)\n      : last;\n  const visible = {first, last};\n\n  // We want to limit the number of new cells we're rendering per batch so that we can fill the\n  // content on the screen quickly. If we rendered the entire overscan window at once, the user\n  // could be staring at white space for a long time waiting for a bunch of offscreen content to\n  // render.\n  let newCellCount = newRangeCount(prev, visible);\n\n  while (true) {\n    if (first <= overscanFirst && last >= overscanLast) {\n      // If we fill the entire overscan range, we're done.\n      break;\n    }\n    const maxNewCells = newCellCount >= maxToRenderPerBatch;\n    const firstWillAddMore = first <= prev.first || first > prev.last;\n    const firstShouldIncrement =\n      first > overscanFirst && (!maxNewCells || !firstWillAddMore);\n    const lastWillAddMore = last >= prev.last || last < prev.first;\n    const lastShouldIncrement =\n      last < overscanLast && (!maxNewCells || !lastWillAddMore);\n    if (maxNewCells && !firstShouldIncrement && !lastShouldIncrement) {\n      // We only want to stop if we've hit maxNewCells AND we cannot increment first or last\n      // without rendering new items. This let's us preserve as many already rendered items as\n      // possible, reducing render churn and keeping the rendered overscan range as large as\n      // possible.\n      break;\n    }\n    if (\n      firstShouldIncrement &&\n      !(fillPreference === 'after' && lastShouldIncrement && lastWillAddMore)\n    ) {\n      if (firstWillAddMore) {\n        newCellCount++;\n      }\n      first--;\n    }\n    if (\n      lastShouldIncrement &&\n      !(fillPreference === 'before' && firstShouldIncrement && firstWillAddMore)\n    ) {\n      if (lastWillAddMore) {\n        newCellCount++;\n      }\n      last++;\n    }\n  }\n  if (\n    !(\n      last >= first &&\n      first >= 0 &&\n      last < itemCount &&\n      first >= overscanFirst &&\n      last <= overscanLast &&\n      first <= visible.first &&\n      last >= visible.last\n    )\n  ) {\n    throw new Error(\n      'Bad window calculation ' +\n        JSON.stringify({\n          first,\n          last,\n          itemCount,\n          overscanFirst,\n          overscanLast,\n          visible,\n        }),\n    );\n  }\n  return {first, last};\n}\n\nconst VirtualizeUtils = {\n  computeWindowedRenderLimits,\n  elementsThatOverlapOffsets,\n  newRangeCount,\n};\n\nmodule.exports = VirtualizeUtils;\n"],"mappings":"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"}