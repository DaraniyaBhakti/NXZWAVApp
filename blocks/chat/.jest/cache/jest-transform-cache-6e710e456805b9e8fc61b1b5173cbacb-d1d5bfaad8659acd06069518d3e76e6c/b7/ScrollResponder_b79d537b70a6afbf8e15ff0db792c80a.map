{"version":3,"names":["Dimensions","require","FrameRateLogger","Keyboard","ReactNative","TextInputState","UIManager","invariant","nullthrows","performanceNow","warning","_require","ScrollViewManager","IS_ANIMATING_TOUCH_START_THRESHOLD_MS","ScrollResponderMixin","_subscriptionKeyboardWillShow","_subscriptionKeyboardWillHide","_subscriptionKeyboardDidShow","_subscriptionKeyboardDidHide","scrollResponderMixinGetInitialState","isTouching","lastMomentumScrollBeginTime","lastMomentumScrollEndTime","observedScrollSinceBecomingResponder","becameResponderWhileAnimating","scrollResponderHandleScrollShouldSetResponder","props","disableScrollViewPanResponder","state","scrollResponderHandleStartShouldSetResponder","e","currentlyFocusedTextInput","currentlyFocusedField","keyboardShouldPersistTaps","target","scrollResponderHandleStartShouldSetResponderCapture","scrollResponderIsAnimating","keyboardNeverPersistTaps","isTextInput","scrollResponderHandleResponderReject","scrollResponderHandleTerminationRequest","scrollResponderHandleTouchEnd","nativeEvent","touches","length","onTouchEnd","scrollResponderHandleTouchCancel","onTouchCancel","scrollResponderHandleResponderRelease","onResponderRelease","onScrollResponderKeyboardDismissed","blurTextInput","scrollResponderHandleScroll","onScroll","scrollResponderHandleResponderGrant","onResponderGrant","scrollResponderHandleScrollBeginDrag","beginScroll","onScrollBeginDrag","scrollResponderHandleScrollEndDrag","velocity","x","y","endScroll","onScrollEndDrag","scrollResponderHandleMomentumScrollBegin","onMomentumScrollBegin","scrollResponderHandleMomentumScrollEnd","onMomentumScrollEnd","scrollResponderHandleTouchStart","onTouchStart","scrollResponderHandleTouchMove","onTouchMove","now","timeSinceLastMomentumScrollEnd","isAnimating","scrollResponderGetScrollableNode","getScrollableNode","findNodeHandle","scrollResponderScrollTo","animated","console","warn","_ref","dispatchViewManagerCommand","getViewManagerConfig","Commands","scrollTo","scrollResponderScrollToEnd","options","scrollToEnd","scrollResponderScrollWithoutAnimationTo","offsetX","offsetY","scrollResponderZoomTo","rect","zoomToRect","scrollResponderFlashScrollIndicators","flashScrollIndicators","scrollResponderScrollNativeHandleToKeyboard","nodeHandle","additionalOffset","preventNegativeScrollOffset","additionalScrollOffset","measureLayout","getInnerViewNode","scrollResponderTextInputFocusError","scrollResponderInputMeasureAndScrollToKeyboard","left","top","width","height","keyboardScreenY","get","keyboardWillOpenTo","endCoordinates","screenY","scrollOffsetY","Math","max","msg","error","UNSAFE_componentWillMount","addListener","scrollResponderKeyboardWillShow","scrollResponderKeyboardWillHide","scrollResponderKeyboardDidShow","scrollResponderKeyboardDidHide","componentWillUnmount","remove","onKeyboardWillShow","onKeyboardWillHide","onKeyboardDidShow","onKeyboardDidHide","ScrollResponder","Mixin","module","exports"],"sources":["ScrollResponder.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * @flow\n */\n\n'use strict';\n\nconst Dimensions = require('../Utilities/Dimensions');\nconst FrameRateLogger = require('../Interaction/FrameRateLogger');\nconst Keyboard = require('./Keyboard/Keyboard');\nconst ReactNative = require('../Renderer/shims/ReactNative');\nconst TextInputState = require('./TextInput/TextInputState');\nconst UIManager = require('../ReactNative/UIManager');\n\nconst invariant = require('invariant');\nconst nullthrows = require('nullthrows');\nconst performanceNow = require('fbjs/lib/performanceNow');\nconst warning = require('fbjs/lib/warning');\n\nconst {ScrollViewManager} = require('../BatchedBridge/NativeModules');\n\nimport type {PressEvent, ScrollEvent} from '../Types/CoreEventTypes';\nimport type {KeyboardEvent} from './Keyboard/Keyboard';\nimport type EmitterSubscription from '../vendor/emitter/EmitterSubscription';\n\n/**\n * Mixin that can be integrated in order to handle scrolling that plays well\n * with `ResponderEventPlugin`. Integrate with your platform specific scroll\n * views, or even your custom built (every-frame animating) scroll views so that\n * all of these systems play well with the `ResponderEventPlugin`.\n *\n * iOS scroll event timing nuances:\n * ===============================\n *\n *\n * Scrolling without bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... physical touch starts ...\n * 2. `onTouchStartCapture`   (when you press down to stop the scroll)\n * 3. `onTouchStart`          (same, but bubble phase)\n * 4. `onResponderRelease`    (when lifting up - you could pause forever before * lifting)\n * 5. `onMomentumScrollEnd`\n *\n *\n * Scrolling with bouncing, if you touch down:\n * -------------------------------\n *\n * 1. `onMomentumScrollBegin` (when animation begins after letting up)\n *    ... bounce begins ...\n *    ... some time elapses ...\n *    ... physical touch during bounce ...\n * 2. `onMomentumScrollEnd`   (Makes no sense why this occurs first during bounce)\n * 3. `onTouchStartCapture`   (immediately after `onMomentumScrollEnd`)\n * 4. `onTouchStart`          (same, but bubble phase)\n * 5. `onTouchEnd`            (You could hold the touch start for a long time)\n * 6. `onMomentumScrollBegin` (When releasing the view starts bouncing back)\n *\n * So when we receive an `onTouchStart`, how can we tell if we are touching\n * *during* an animation (which then causes the animation to stop)? The only way\n * to tell is if the `touchStart` occurred immediately after the\n * `onMomentumScrollEnd`.\n *\n * This is abstracted out for you, so you can just call this.scrollResponderIsAnimating() if\n * necessary\n *\n * `ScrollResponder` also includes logic for blurring a currently focused input\n * if one is focused while scrolling. The `ScrollResponder` is a natural place\n * to put this logic since it can support not dismissing the keyboard while\n * scrolling, unless a recognized \"tap\"-like gesture has occurred.\n *\n * The public lifecycle API includes events for keyboard interaction, responder\n * interaction, and scrolling (among others). The keyboard callbacks\n * `onKeyboardWill/Did/*` are *global* events, but are invoked on scroll\n * responder's props so that you can guarantee that the scroll responder's\n * internal state has been updated accordingly (and deterministically) by\n * the time the props callbacks are invoke. Otherwise, you would always wonder\n * if the scroll responder is currently in a state where it recognizes new\n * keyboard positions etc. If coordinating scrolling with keyboard movement,\n * *always* use these hooks instead of listening to your own global keyboard\n * events.\n *\n * Public keyboard lifecycle API: (props callbacks)\n *\n * Standard Keyboard Appearance Sequence:\n *\n *   this.props.onKeyboardWillShow\n *   this.props.onKeyboardDidShow\n *\n * `onScrollResponderKeyboardDismissed` will be invoked if an appropriate\n * tap inside the scroll responder's scrollable region was responsible\n * for the dismissal of the keyboard. There are other reasons why the\n * keyboard could be dismissed.\n *\n *   this.props.onScrollResponderKeyboardDismissed\n *\n * Standard Keyboard Hide Sequence:\n *\n *   this.props.onKeyboardWillHide\n *   this.props.onKeyboardDidHide\n */\n\nconst IS_ANIMATING_TOUCH_START_THRESHOLD_MS = 16;\n\nexport type State = {|\n  isTouching: boolean,\n  lastMomentumScrollBeginTime: number,\n  lastMomentumScrollEndTime: number,\n  observedScrollSinceBecomingResponder: boolean,\n  becameResponderWhileAnimating: boolean,\n|};\n\nconst ScrollResponderMixin = {\n  _subscriptionKeyboardWillShow: (null: ?EmitterSubscription),\n  _subscriptionKeyboardWillHide: (null: ?EmitterSubscription),\n  _subscriptionKeyboardDidShow: (null: ?EmitterSubscription),\n  _subscriptionKeyboardDidHide: (null: ?EmitterSubscription),\n  scrollResponderMixinGetInitialState: function(): State {\n    return {\n      isTouching: false,\n      lastMomentumScrollBeginTime: 0,\n      lastMomentumScrollEndTime: 0,\n\n      // Reset to false every time becomes responder. This is used to:\n      // - Determine if the scroll view has been scrolled and therefore should\n      // refuse to give up its responder lock.\n      // - Determine if releasing should dismiss the keyboard when we are in\n      // tap-to-dismiss mode (this.props.keyboardShouldPersistTaps !== 'always').\n      observedScrollSinceBecomingResponder: false,\n      becameResponderWhileAnimating: false,\n    };\n  },\n\n  /**\n   * Invoke this from an `onScroll` event.\n   */\n  scrollResponderHandleScrollShouldSetResponder: function(): boolean {\n    // Allow any event touch pass through if the default pan responder is disabled\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n    return this.state.isTouching;\n  },\n\n  /**\n   * Merely touch starting is not sufficient for a scroll view to become the\n   * responder. Being the \"responder\" means that the very next touch move/end\n   * event will result in an action/movement.\n   *\n   * Invoke this from an `onStartShouldSetResponder` event.\n   *\n   * `onStartShouldSetResponder` is used when the next move/end will trigger\n   * some UI movement/action, but when you want to yield priority to views\n   * nested inside of the view.\n   *\n   * There may be some cases where scroll views actually should return `true`\n   * from `onStartShouldSetResponder`: Any time we are detecting a standard tap\n   * that gives priority to nested views.\n   *\n   * - If a single tap on the scroll view triggers an action such as\n   *   recentering a map style view yet wants to give priority to interaction\n   *   views inside (such as dropped pins or labels), then we would return true\n   *   from this method when there is a single touch.\n   *\n   * - Similar to the previous case, if a two finger \"tap\" should trigger a\n   *   zoom, we would check the `touches` count, and if `>= 2`, we would return\n   *   true.\n   *\n   */\n  scrollResponderHandleStartShouldSetResponder: function(\n    e: PressEvent,\n  ): boolean {\n    // Allow any event touch pass through if the default pan responder is disabled\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n\n    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n\n    if (\n      this.props.keyboardShouldPersistTaps === 'handled' &&\n      currentlyFocusedTextInput != null &&\n      e.target !== currentlyFocusedTextInput\n    ) {\n      return true;\n    }\n    return false;\n  },\n\n  /**\n   * There are times when the scroll view wants to become the responder\n   * (meaning respond to the next immediate `touchStart/touchEnd`), in a way\n   * that *doesn't* give priority to nested views (hence the capture phase):\n   *\n   * - Currently animating.\n   * - Tapping anywhere that is not a text input, while the keyboard is\n   *   up (which should dismiss the keyboard).\n   *\n   * Invoke this from an `onStartShouldSetResponderCapture` event.\n   */\n  scrollResponderHandleStartShouldSetResponderCapture: function(\n    e: PressEvent,\n  ): boolean {\n    // The scroll view should receive taps instead of its descendants if:\n    // * it is already animating/decelerating\n    if (this.scrollResponderIsAnimating()) {\n      return true;\n    }\n\n    // Allow any event touch pass through if the default pan responder is disabled\n    if (this.props.disableScrollViewPanResponder === true) {\n      return false;\n    }\n\n    // * the keyboard is up, keyboardShouldPersistTaps is 'never' (the default),\n    // and a new touch starts with a non-textinput target (in which case the\n    // first tap should be sent to the scroll view and dismiss the keyboard,\n    // then the second tap goes to the actual interior view)\n    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n    const {keyboardShouldPersistTaps} = this.props;\n    const keyboardNeverPersistTaps =\n      !keyboardShouldPersistTaps || keyboardShouldPersistTaps === 'never';\n    if (\n      keyboardNeverPersistTaps &&\n      currentlyFocusedTextInput != null &&\n      e.target &&\n      !TextInputState.isTextInput(e.target)\n    ) {\n      return true;\n    }\n\n    return false;\n  },\n\n  /**\n   * Invoke this from an `onResponderReject` event.\n   *\n   * Some other element is not yielding its role as responder. Normally, we'd\n   * just disable the `UIScrollView`, but a touch has already began on it, the\n   * `UIScrollView` will not accept being disabled after that. The easiest\n   * solution for now is to accept the limitation of disallowing this\n   * altogether. To improve this, find a way to disable the `UIScrollView` after\n   * a touch has already started.\n   */\n  scrollResponderHandleResponderReject: function() {},\n\n  /**\n   * We will allow the scroll view to give up its lock iff it acquired the lock\n   * during an animation. This is a very useful default that happens to satisfy\n   * many common user experiences.\n   *\n   * - Stop a scroll on the left edge, then turn that into an outer view's\n   *   backswipe.\n   * - Stop a scroll mid-bounce at the top, continue pulling to have the outer\n   *   view dismiss.\n   * - However, without catching the scroll view mid-bounce (while it is\n   *   motionless), if you drag far enough for the scroll view to become\n   *   responder (and therefore drag the scroll view a bit), any backswipe\n   *   navigation of a swipe gesture higher in the view hierarchy, should be\n   *   rejected.\n   */\n  scrollResponderHandleTerminationRequest: function(): boolean {\n    return !this.state.observedScrollSinceBecomingResponder;\n  },\n\n  /**\n   * Invoke this from an `onTouchEnd` event.\n   *\n   * @param {PressEvent} e Event.\n   */\n  scrollResponderHandleTouchEnd: function(e: PressEvent) {\n    const nativeEvent = e.nativeEvent;\n    this.state.isTouching = nativeEvent.touches.length !== 0;\n    this.props.onTouchEnd && this.props.onTouchEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchCancel` event.\n   *\n   * @param {PressEvent} e Event.\n   */\n  scrollResponderHandleTouchCancel: function(e: PressEvent) {\n    this.state.isTouching = false;\n    this.props.onTouchCancel && this.props.onTouchCancel(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderRelease` event.\n   */\n  scrollResponderHandleResponderRelease: function(e: PressEvent) {\n    this.props.onResponderRelease && this.props.onResponderRelease(e);\n\n    // By default scroll views will unfocus a textField\n    // if another touch occurs outside of it\n    const currentlyFocusedTextInput = TextInputState.currentlyFocusedField();\n    if (\n      this.props.keyboardShouldPersistTaps !== true &&\n      this.props.keyboardShouldPersistTaps !== 'always' &&\n      currentlyFocusedTextInput != null &&\n      e.target !== currentlyFocusedTextInput &&\n      !this.state.observedScrollSinceBecomingResponder &&\n      !this.state.becameResponderWhileAnimating\n    ) {\n      this.props.onScrollResponderKeyboardDismissed &&\n        this.props.onScrollResponderKeyboardDismissed(e);\n      TextInputState.blurTextInput(currentlyFocusedTextInput);\n    }\n  },\n\n  scrollResponderHandleScroll: function(e: ScrollEvent) {\n    this.state.observedScrollSinceBecomingResponder = true;\n    this.props.onScroll && this.props.onScroll(e);\n  },\n\n  /**\n   * Invoke this from an `onResponderGrant` event.\n   */\n  scrollResponderHandleResponderGrant: function(e: ScrollEvent) {\n    this.state.observedScrollSinceBecomingResponder = false;\n    this.props.onResponderGrant && this.props.onResponderGrant(e);\n    this.state.becameResponderWhileAnimating = this.scrollResponderIsAnimating();\n  },\n\n  /**\n   * Unfortunately, `onScrollBeginDrag` also fires when *stopping* the scroll\n   * animation, and there's not an easy way to distinguish a drag vs. stopping\n   * momentum.\n   *\n   * Invoke this from an `onScrollBeginDrag` event.\n   */\n  scrollResponderHandleScrollBeginDrag: function(e: ScrollEvent) {\n    FrameRateLogger.beginScroll(); // TODO: track all scrolls after implementing onScrollEndAnimation\n    this.props.onScrollBeginDrag && this.props.onScrollBeginDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onScrollEndDrag` event.\n   */\n  scrollResponderHandleScrollEndDrag: function(e: ScrollEvent) {\n    const {velocity} = e.nativeEvent;\n    // - If we are animating, then this is a \"drag\" that is stopping the scrollview and momentum end\n    //   will fire.\n    // - If velocity is non-zero, then the interaction will stop when momentum scroll ends or\n    //   another drag starts and ends.\n    // - If we don't get velocity, better to stop the interaction twice than not stop it.\n    if (\n      !this.scrollResponderIsAnimating() &&\n      (!velocity || (velocity.x === 0 && velocity.y === 0))\n    ) {\n      FrameRateLogger.endScroll();\n    }\n    this.props.onScrollEndDrag && this.props.onScrollEndDrag(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollBegin` event.\n   */\n  scrollResponderHandleMomentumScrollBegin: function(e: ScrollEvent) {\n    this.state.lastMomentumScrollBeginTime = performanceNow();\n    this.props.onMomentumScrollBegin && this.props.onMomentumScrollBegin(e);\n  },\n\n  /**\n   * Invoke this from an `onMomentumScrollEnd` event.\n   */\n  scrollResponderHandleMomentumScrollEnd: function(e: ScrollEvent) {\n    FrameRateLogger.endScroll();\n    this.state.lastMomentumScrollEndTime = performanceNow();\n    this.props.onMomentumScrollEnd && this.props.onMomentumScrollEnd(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchStart` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {PressEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchStart: function(e: PressEvent) {\n    this.state.isTouching = true;\n    this.props.onTouchStart && this.props.onTouchStart(e);\n  },\n\n  /**\n   * Invoke this from an `onTouchMove` event.\n   *\n   * Since we know that the `SimpleEventPlugin` occurs later in the plugin\n   * order, after `ResponderEventPlugin`, we can detect that we were *not*\n   * permitted to be the responder (presumably because a contained view became\n   * responder). The `onResponderReject` won't fire in that case - it only\n   * fires when a *current* responder rejects our request.\n   *\n   * @param {PressEvent} e Touch Start event.\n   */\n  scrollResponderHandleTouchMove: function(e: PressEvent) {\n    this.props.onTouchMove && this.props.onTouchMove(e);\n  },\n\n  /**\n   * A helper function for this class that lets us quickly determine if the\n   * view is currently animating. This is particularly useful to know when\n   * a touch has just started or ended.\n   */\n  scrollResponderIsAnimating: function(): boolean {\n    const now = performanceNow();\n    const timeSinceLastMomentumScrollEnd =\n      now - this.state.lastMomentumScrollEndTime;\n    const isAnimating =\n      timeSinceLastMomentumScrollEnd < IS_ANIMATING_TOUCH_START_THRESHOLD_MS ||\n      this.state.lastMomentumScrollEndTime <\n        this.state.lastMomentumScrollBeginTime;\n    return isAnimating;\n  },\n\n  /**\n   * Returns the node that represents native view that can be scrolled.\n   * Components can pass what node to use by defining a `getScrollableNode`\n   * function otherwise `this` is used.\n   */\n  scrollResponderGetScrollableNode: function(): ?number {\n    return this.getScrollableNode\n      ? this.getScrollableNode()\n      : ReactNative.findNodeHandle(this);\n  },\n\n  /**\n   * A helper function to scroll to a specific point in the ScrollView.\n   * This is currently used to help focus child TextViews, but can also\n   * be used to quickly scroll to any element we want to focus. Syntax:\n   *\n   * `scrollResponderScrollTo(options: {x: number = 0; y: number = 0; animated: boolean = true})`\n   *\n   * Note: The weird argument signature is due to the fact that, for historical reasons,\n   * the function also accepts separate arguments as as alternative to the options object.\n   * This is deprecated due to ambiguity (y before x), and SHOULD NOT BE USED.\n   */\n  scrollResponderScrollTo: function(\n    x?: number | {x?: number, y?: number, animated?: boolean},\n    y?: number,\n    animated?: boolean,\n  ) {\n    if (typeof x === 'number') {\n      console.warn(\n        '`scrollResponderScrollTo(x, y, animated)` is deprecated. Use `scrollResponderScrollTo({x: 5, y: 5, animated: true})` instead.',\n      );\n    } else {\n      ({x, y, animated} = x || {});\n    }\n    UIManager.dispatchViewManagerCommand(\n      nullthrows(this.scrollResponderGetScrollableNode()),\n      UIManager.getViewManagerConfig('RCTScrollView').Commands.scrollTo,\n      [x || 0, y || 0, animated !== false],\n    );\n  },\n\n  /**\n   * Scrolls to the end of the ScrollView, either immediately or with a smooth\n   * animation.\n   *\n   * Example:\n   *\n   * `scrollResponderScrollToEnd({animated: true})`\n   */\n  scrollResponderScrollToEnd: function(options?: {animated?: boolean}) {\n    // Default to true\n    const animated = (options && options.animated) !== false;\n    UIManager.dispatchViewManagerCommand(\n      this.scrollResponderGetScrollableNode(),\n      UIManager.getViewManagerConfig('RCTScrollView').Commands.scrollToEnd,\n      [animated],\n    );\n  },\n\n  /**\n   * Deprecated, do not use.\n   */\n  scrollResponderScrollWithoutAnimationTo: function(\n    offsetX: number,\n    offsetY: number,\n  ) {\n    console.warn(\n      '`scrollResponderScrollWithoutAnimationTo` is deprecated. Use `scrollResponderScrollTo` instead',\n    );\n    this.scrollResponderScrollTo({x: offsetX, y: offsetY, animated: false});\n  },\n\n  /**\n   * A helper function to zoom to a specific rect in the scrollview. The argument has the shape\n   * {x: number; y: number; width: number; height: number; animated: boolean = true}\n   *\n   * @platform ios\n   */\n  scrollResponderZoomTo: function(\n    rect: {|\n      x: number,\n      y: number,\n      width: number,\n      height: number,\n      animated?: boolean,\n    |},\n    animated?: boolean, // deprecated, put this inside the rect argument instead\n  ) {\n    invariant(\n      ScrollViewManager && ScrollViewManager.zoomToRect,\n      'zoomToRect is not implemented',\n    );\n    if ('animated' in rect) {\n      animated = rect.animated;\n      delete rect.animated;\n    } else if (typeof animated !== 'undefined') {\n      console.warn(\n        '`scrollResponderZoomTo` `animated` argument is deprecated. Use `options.animated` instead',\n      );\n    }\n    ScrollViewManager.zoomToRect(\n      this.scrollResponderGetScrollableNode(),\n      rect,\n      animated !== false,\n    );\n  },\n\n  /**\n   * Displays the scroll indicators momentarily.\n   */\n  scrollResponderFlashScrollIndicators: function() {\n    UIManager.dispatchViewManagerCommand(\n      this.scrollResponderGetScrollableNode(),\n      UIManager.getViewManagerConfig('RCTScrollView').Commands\n        .flashScrollIndicators,\n      [],\n    );\n  },\n\n  /**\n   * This method should be used as the callback to onFocus in a TextInputs'\n   * parent view. Note that any module using this mixin needs to return\n   * the parent view's ref in getScrollViewRef() in order to use this method.\n   * @param {number} nodeHandle The TextInput node handle\n   * @param {number} additionalOffset The scroll view's bottom \"contentInset\".\n   *        Default is 0.\n   * @param {bool} preventNegativeScrolling Whether to allow pulling the content\n   *        down to make it meet the keyboard's top. Default is false.\n   */\n  scrollResponderScrollNativeHandleToKeyboard: function(\n    nodeHandle: number,\n    additionalOffset?: number,\n    preventNegativeScrollOffset?: boolean,\n  ) {\n    this.additionalScrollOffset = additionalOffset || 0;\n    this.preventNegativeScrollOffset = !!preventNegativeScrollOffset;\n    UIManager.measureLayout(\n      nodeHandle,\n      ReactNative.findNodeHandle(this.getInnerViewNode()),\n      this.scrollResponderTextInputFocusError,\n      this.scrollResponderInputMeasureAndScrollToKeyboard,\n    );\n  },\n\n  /**\n   * The calculations performed here assume the scroll view takes up the entire\n   * screen - even if has some content inset. We then measure the offsets of the\n   * keyboard, and compensate both for the scroll view's \"contentInset\".\n   *\n   * @param {number} left Position of input w.r.t. table view.\n   * @param {number} top Position of input w.r.t. table view.\n   * @param {number} width Width of the text input.\n   * @param {number} height Height of the text input.\n   */\n  scrollResponderInputMeasureAndScrollToKeyboard: function(\n    left: number,\n    top: number,\n    width: number,\n    height: number,\n  ) {\n    let keyboardScreenY = Dimensions.get('window').height;\n    if (this.keyboardWillOpenTo) {\n      keyboardScreenY = this.keyboardWillOpenTo.endCoordinates.screenY;\n    }\n    let scrollOffsetY =\n      top - keyboardScreenY + height + this.additionalScrollOffset;\n\n    // By default, this can scroll with negative offset, pulling the content\n    // down so that the target component's bottom meets the keyboard's top.\n    // If requested otherwise, cap the offset at 0 minimum to avoid content\n    // shifting down.\n    if (this.preventNegativeScrollOffset) {\n      scrollOffsetY = Math.max(0, scrollOffsetY);\n    }\n    this.scrollResponderScrollTo({x: 0, y: scrollOffsetY, animated: true});\n\n    this.additionalOffset = 0;\n    this.preventNegativeScrollOffset = false;\n  },\n\n  scrollResponderTextInputFocusError: function(msg: string) {\n    console.error('Error measuring text field: ', msg);\n  },\n\n  /**\n   * `componentWillMount` is the closest thing to a  standard \"constructor\" for\n   * React components.\n   *\n   * The `keyboardWillShow` is called before input focus.\n   */\n  UNSAFE_componentWillMount: function() {\n    const {keyboardShouldPersistTaps} = this.props;\n    warning(\n      typeof keyboardShouldPersistTaps !== 'boolean',\n      `'keyboardShouldPersistTaps={${keyboardShouldPersistTaps}}' is deprecated. ` +\n        `Use 'keyboardShouldPersistTaps=\"${\n          keyboardShouldPersistTaps ? 'always' : 'never'\n        }\"' instead`,\n    );\n\n    this.keyboardWillOpenTo = null;\n    this.additionalScrollOffset = 0;\n    this._subscriptionKeyboardWillShow = Keyboard.addListener(\n      'keyboardWillShow',\n      this.scrollResponderKeyboardWillShow,\n    );\n\n    this._subscriptionKeyboardWillHide = Keyboard.addListener(\n      'keyboardWillHide',\n      this.scrollResponderKeyboardWillHide,\n    );\n    this._subscriptionKeyboardDidShow = Keyboard.addListener(\n      'keyboardDidShow',\n      this.scrollResponderKeyboardDidShow,\n    );\n    this._subscriptionKeyboardDidHide = Keyboard.addListener(\n      'keyboardDidHide',\n      this.scrollResponderKeyboardDidHide,\n    );\n  },\n\n  componentWillUnmount: function() {\n    if (this._subscriptionKeyboardWillShow != null) {\n      this._subscriptionKeyboardWillShow.remove();\n    }\n    if (this._subscriptionKeyboardWillHide != null) {\n      this._subscriptionKeyboardWillHide.remove();\n    }\n    if (this._subscriptionKeyboardDidShow != null) {\n      this._subscriptionKeyboardDidShow.remove();\n    }\n    if (this._subscriptionKeyboardDidHide != null) {\n      this._subscriptionKeyboardDidHide.remove();\n    }\n  },\n\n  /**\n   * Warning, this may be called several times for a single keyboard opening.\n   * It's best to store the information in this method and then take any action\n   * at a later point (either in `keyboardDidShow` or other).\n   *\n   * Here's the order that events occur in:\n   * - focus\n   * - willShow {startCoordinates, endCoordinates} several times\n   * - didShow several times\n   * - blur\n   * - willHide {startCoordinates, endCoordinates} several times\n   * - didHide several times\n   *\n   * The `ScrollResponder` module callbacks for each of these events.\n   * Even though any user could have easily listened to keyboard events\n   * themselves, using these `props` callbacks ensures that ordering of events\n   * is consistent - and not dependent on the order that the keyboard events are\n   * subscribed to. This matters when telling the scroll view to scroll to where\n   * the keyboard is headed - the scroll responder better have been notified of\n   * the keyboard destination before being instructed to scroll to where the\n   * keyboard will be. Stick to the `ScrollResponder` callbacks, and everything\n   * will work.\n   *\n   * WARNING: These callbacks will fire even if a keyboard is displayed in a\n   * different navigation pane. Filter out the events to determine if they are\n   * relevant to you. (For example, only if you receive these callbacks after\n   * you had explicitly focused a node etc).\n   */\n  scrollResponderKeyboardWillShow: function(e: KeyboardEvent) {\n    this.keyboardWillOpenTo = e;\n    this.props.onKeyboardWillShow && this.props.onKeyboardWillShow(e);\n  },\n\n  scrollResponderKeyboardWillHide: function(e: KeyboardEvent) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardWillHide && this.props.onKeyboardWillHide(e);\n  },\n\n  scrollResponderKeyboardDidShow: function(e: KeyboardEvent) {\n    // TODO(7693961): The event for DidShow is not available on iOS yet.\n    // Use the one from WillShow and do not assign.\n    if (e) {\n      this.keyboardWillOpenTo = e;\n    }\n    this.props.onKeyboardDidShow && this.props.onKeyboardDidShow(e);\n  },\n\n  scrollResponderKeyboardDidHide: function(e: KeyboardEvent) {\n    this.keyboardWillOpenTo = null;\n    this.props.onKeyboardDidHide && this.props.onKeyboardDidHide(e);\n  },\n};\n\nconst ScrollResponder = {\n  Mixin: ScrollResponderMixin,\n};\n\nmodule.exports = ScrollResponder;\n"],"mappings":"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"}