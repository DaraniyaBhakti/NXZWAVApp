{"version":3,"names":["_interopRequireDefault","require","_classCallCheck2","_createClass2","_inherits2","_possibleConstructorReturn2","_getPrototypeOf2","_createSuper","Derived","hasNativeReflectConstruct","_isNativeReflectConstruct","_createSuperInternal","Super","default","result","NewTarget","constructor","Reflect","construct","arguments","apply","sham","Proxy","Boolean","prototype","valueOf","call","e","AnimatedImplementation","React","StyleSheet","View","AnimatedView","createAnimatedComponent","ScrollViewStickyHeader","_React$Component","_super","_this","_len","length","args","Array","_key","concat","state","measured","layoutY","layoutHeight","nextHeaderLayoutY","props","_onLayout","event","setState","nativeEvent","layout","y","height","onLayout","child","Children","only","children","key","value","setNextHeaderY","render","_this$props","inverted","scrollViewHeight","_this$state","inputRange","outputRange","stickStartPoint","push","collisionPoint","translateY","scrollAnimatedValue","interpolate","createElement","collapsable","style","styles","header","transform","cloneElement","fill","undefined","Component","create","zIndex","flex","module","exports"],"sources":["ScrollViewStickyHeader.js"],"sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @flow\n * @format\n */\n'use strict';\n\nconst AnimatedImplementation = require('../../Animated/src/AnimatedImplementation');\nconst React = require('react');\nconst StyleSheet = require('../../StyleSheet/StyleSheet');\nconst View = require('../View/View');\n\nimport type {LayoutEvent} from '../../Types/CoreEventTypes';\n\nconst AnimatedView = AnimatedImplementation.createAnimatedComponent(View);\n\nexport type Props = {\n  children?: React.Element<any>,\n  nextHeaderLayoutY: ?number,\n  onLayout: (event: LayoutEvent) => void,\n  scrollAnimatedValue: AnimatedImplementation.Value,\n  // Will cause sticky headers to stick at the bottom of the ScrollView instead\n  // of the top.\n  inverted: ?boolean,\n  // The height of the parent ScrollView. Currently only set when inverted.\n  scrollViewHeight: ?number,\n};\n\ntype State = {\n  measured: boolean,\n  layoutY: number,\n  layoutHeight: number,\n  nextHeaderLayoutY: ?number,\n};\n\nclass ScrollViewStickyHeader extends React.Component<Props, State> {\n  state: State = {\n    measured: false,\n    layoutY: 0,\n    layoutHeight: 0,\n    nextHeaderLayoutY: this.props.nextHeaderLayoutY,\n  };\n\n  setNextHeaderY(y: number) {\n    this.setState({nextHeaderLayoutY: y});\n  }\n\n  _onLayout = event => {\n    this.setState({\n      measured: true,\n      layoutY: event.nativeEvent.layout.y,\n      layoutHeight: event.nativeEvent.layout.height,\n    });\n\n    this.props.onLayout(event);\n    const child = React.Children.only(this.props.children);\n    if (child.props.onLayout) {\n      child.props.onLayout(event);\n    }\n  };\n\n  render(): React.Node {\n    const {inverted, scrollViewHeight} = this.props;\n    const {measured, layoutHeight, layoutY, nextHeaderLayoutY} = this.state;\n    const inputRange: Array<number> = [-1, 0];\n    const outputRange: Array<number> = [0, 0];\n\n    if (measured) {\n      if (inverted) {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - `stickStartPoint` is the point at which the header will start sticking.\n        //   It is calculated using the ScrollView viewport height so it is a the bottom.\n        // - Headers that are in the initial viewport will never stick, `stickStartPoint`\n        //   will be negative.\n        // - From 0 to `stickStartPoint` no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From `stickStartPoint` to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        if (scrollViewHeight != null) {\n          const stickStartPoint = layoutY + layoutHeight - scrollViewHeight;\n          if (stickStartPoint > 0) {\n            inputRange.push(stickStartPoint);\n            outputRange.push(0);\n            inputRange.push(stickStartPoint + 1);\n            outputRange.push(1);\n            // If the next sticky header has not loaded yet (probably windowing) or is the last\n            // we can just keep it sticked forever.\n            const collisionPoint =\n              (nextHeaderLayoutY || 0) - layoutHeight - scrollViewHeight;\n            if (collisionPoint > stickStartPoint) {\n              inputRange.push(collisionPoint, collisionPoint + 1);\n              outputRange.push(\n                collisionPoint - stickStartPoint,\n                collisionPoint - stickStartPoint,\n              );\n            }\n          }\n        }\n      } else {\n        // The interpolation looks like:\n        // - Negative scroll: no translation\n        // - From 0 to the y of the header: no translation. This will cause the header\n        //   to scroll normally until it reaches the top of the scroll view.\n        // - From header y to when the next header y hits the bottom edge of the header: translate\n        //   equally to scroll. This will cause the header to stay at the top of the scroll view.\n        // - Past the collision with the next header y: no more translation. This will cause the\n        //   header to continue scrolling up and make room for the next sticky header.\n        //   In the case that there is no next header just translate equally to\n        //   scroll indefinitely.\n        inputRange.push(layoutY);\n        outputRange.push(0);\n        // If the next sticky header has not loaded yet (probably windowing) or is the last\n        // we can just keep it sticked forever.\n        const collisionPoint = (nextHeaderLayoutY || 0) - layoutHeight;\n        if (collisionPoint >= layoutY) {\n          inputRange.push(collisionPoint, collisionPoint + 1);\n          outputRange.push(collisionPoint - layoutY, collisionPoint - layoutY);\n        } else {\n          inputRange.push(layoutY + 1);\n          outputRange.push(1);\n        }\n      }\n    }\n\n    const translateY = this.props.scrollAnimatedValue.interpolate({\n      inputRange,\n      outputRange,\n    });\n    const child = React.Children.only(this.props.children);\n\n    return (\n      <AnimatedView\n        collapsable={false}\n        onLayout={this._onLayout}\n        style={[child.props.style, styles.header, {transform: [{translateY}]}]}>\n        {React.cloneElement(child, {\n          style: styles.fill, // We transfer the child style to the wrapper.\n          onLayout: undefined, // we call this manually through our this._onLayout\n        })}\n      </AnimatedView>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  header: {\n    zIndex: 10,\n  },\n  fill: {\n    flex: 1,\n  },\n});\n\nmodule.exports = ScrollViewStickyHeader;\n"],"mappings":"AASA,YAAY;;AAAC,IAAAA,sBAAA,GAAAC,OAAA;AAAA,IAAAC,gBAAA,GAAAF,sBAAA,CAAAC,OAAA;AAAA,IAAAE,aAAA,GAAAH,sBAAA,CAAAC,OAAA;AAAA,IAAAG,UAAA,GAAAJ,sBAAA,CAAAC,OAAA;AAAA,IAAAI,2BAAA,GAAAL,sBAAA,CAAAC,OAAA;AAAA,IAAAK,gBAAA,GAAAN,sBAAA,CAAAC,OAAA;AAAA,SAAAM,aAAAC,OAAA,QAAAC,yBAAA,GAAAC,yBAAA,oBAAAC,qBAAA,QAAAC,KAAA,OAAAN,gBAAA,CAAAO,OAAA,EAAAL,OAAA,GAAAM,MAAA,MAAAL,yBAAA,QAAAM,SAAA,OAAAT,gBAAA,CAAAO,OAAA,QAAAG,WAAA,EAAAF,MAAA,GAAAG,OAAA,CAAAC,SAAA,CAAAN,KAAA,EAAAO,SAAA,EAAAJ,SAAA,YAAAD,MAAA,GAAAF,KAAA,CAAAQ,KAAA,OAAAD,SAAA,gBAAAd,2BAAA,CAAAQ,OAAA,QAAAC,MAAA;AAAA,SAAAJ,0BAAA,eAAAO,OAAA,qBAAAA,OAAA,CAAAC,SAAA,oBAAAD,OAAA,CAAAC,SAAA,CAAAG,IAAA,2BAAAC,KAAA,oCAAAC,OAAA,CAAAC,SAAA,CAAAC,OAAA,CAAAC,IAAA,CAAAT,OAAA,CAAAC,SAAA,CAAAK,OAAA,8CAAAI,CAAA;AAEb,IAAMC,sBAAsB,GAAG3B,OAAO,CAAC,2CAA2C,CAAC;AACnF,IAAM4B,KAAK,GAAG5B,OAAO,CAAC,OAAO,CAAC;AAC9B,IAAM6B,UAAU,GAAG7B,OAAO,CAAC,6BAA6B,CAAC;AACzD,IAAM8B,IAAI,GAAG9B,OAAO,CAAC,cAAc,CAAC;AAIpC,IAAM+B,YAAY,GAAGJ,sBAAsB,CAACK,uBAAuB,CAACF,IAAI,CAAC;AAAC,IAqBpEG,sBAAsB,aAAAC,gBAAA;EAAA,IAAA/B,UAAA,CAAAS,OAAA,EAAAqB,sBAAA,EAAAC,gBAAA;EAAA,IAAAC,MAAA,GAAA7B,YAAA,CAAA2B,sBAAA;EAAA,SAAAA,uBAAA;IAAA,IAAAG,KAAA;IAAA,IAAAnC,gBAAA,CAAAW,OAAA,QAAAqB,sBAAA;IAAA,SAAAI,IAAA,GAAAnB,SAAA,CAAAoB,MAAA,EAAAC,IAAA,OAAAC,KAAA,CAAAH,IAAA,GAAAI,IAAA,MAAAA,IAAA,GAAAJ,IAAA,EAAAI,IAAA;MAAAF,IAAA,CAAAE,IAAA,IAAAvB,SAAA,CAAAuB,IAAA;IAAA;IAAAL,KAAA,GAAAD,MAAA,CAAAV,IAAA,CAAAN,KAAA,CAAAgB,MAAA,SAAAO,MAAA,CAAAH,IAAA;IAAAH,KAAA,CAC1BO,KAAK,GAAU;MACbC,QAAQ,EAAE,KAAK;MACfC,OAAO,EAAE,CAAC;MACVC,YAAY,EAAE,CAAC;MACfC,iBAAiB,EAAEX,KAAA,CAAKY,KAAK,CAACD;IAChC,CAAC;IAAAX,KAAA,CAMDa,SAAS,GAAG,UAAAC,KAAK,EAAI;MACnBd,KAAA,CAAKe,QAAQ,CAAC;QACZP,QAAQ,EAAE,IAAI;QACdC,OAAO,EAAEK,KAAK,CAACE,WAAW,CAACC,MAAM,CAACC,CAAC;QACnCR,YAAY,EAAEI,KAAK,CAACE,WAAW,CAACC,MAAM,CAACE;MACzC,CAAC,CAAC;MAEFnB,KAAA,CAAKY,KAAK,CAACQ,QAAQ,CAACN,KAAK,CAAC;MAC1B,IAAMO,KAAK,GAAG7B,KAAK,CAAC8B,QAAQ,CAACC,IAAI,CAACvB,KAAA,CAAKY,KAAK,CAACY,QAAQ,CAAC;MACtD,IAAIH,KAAK,CAACT,KAAK,CAACQ,QAAQ,EAAE;QACxBC,KAAK,CAACT,KAAK,CAACQ,QAAQ,CAACN,KAAK,CAAC;MAC7B;IACF,CAAC;IAAA,OAAAd,KAAA;EAAA;EAAA,IAAAlC,aAAA,CAAAU,OAAA,EAAAqB,sBAAA;IAAA4B,GAAA;IAAAC,KAAA,EAhBD,SAAAC,eAAeT,CAAS,EAAE;MACxB,IAAI,CAACH,QAAQ,CAAC;QAACJ,iBAAiB,EAAEO;MAAC,CAAC,CAAC;IACvC;EAAC;IAAAO,GAAA;IAAAC,KAAA,EAgBD,SAAAE,OAAA,EAAqB;MACnB,IAAAC,WAAA,GAAqC,IAAI,CAACjB,KAAK;QAAxCkB,QAAQ,GAAAD,WAAA,CAARC,QAAQ;QAAEC,gBAAgB,GAAAF,WAAA,CAAhBE,gBAAgB;MACjC,IAAAC,WAAA,GAA6D,IAAI,CAACzB,KAAK;QAAhEC,QAAQ,GAAAwB,WAAA,CAARxB,QAAQ;QAAEE,YAAY,GAAAsB,WAAA,CAAZtB,YAAY;QAAED,OAAO,GAAAuB,WAAA,CAAPvB,OAAO;QAAEE,iBAAiB,GAAAqB,WAAA,CAAjBrB,iBAAiB;MACzD,IAAMsB,UAAyB,GAAG,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC;MACzC,IAAMC,WAA0B,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;MAEzC,IAAI1B,QAAQ,EAAE;QACZ,IAAIsB,QAAQ,EAAE;UAeZ,IAAIC,gBAAgB,IAAI,IAAI,EAAE;YAC5B,IAAMI,eAAe,GAAG1B,OAAO,GAAGC,YAAY,GAAGqB,gBAAgB;YACjE,IAAII,eAAe,GAAG,CAAC,EAAE;cACvBF,UAAU,CAACG,IAAI,CAACD,eAAe,CAAC;cAChCD,WAAW,CAACE,IAAI,CAAC,CAAC,CAAC;cACnBH,UAAU,CAACG,IAAI,CAACD,eAAe,GAAG,CAAC,CAAC;cACpCD,WAAW,CAACE,IAAI,CAAC,CAAC,CAAC;cAGnB,IAAMC,cAAc,GAClB,CAAC1B,iBAAiB,IAAI,CAAC,IAAID,YAAY,GAAGqB,gBAAgB;cAC5D,IAAIM,cAAc,GAAGF,eAAe,EAAE;gBACpCF,UAAU,CAACG,IAAI,CAACC,cAAc,EAAEA,cAAc,GAAG,CAAC,CAAC;gBACnDH,WAAW,CAACE,IAAI,CACdC,cAAc,GAAGF,eAAe,EAChCE,cAAc,GAAGF,eACnB,CAAC;cACH;YACF;UACF;QACF,CAAC,MAAM;UAWLF,UAAU,CAACG,IAAI,CAAC3B,OAAO,CAAC;UACxByB,WAAW,CAACE,IAAI,CAAC,CAAC,CAAC;UAGnB,IAAMC,eAAc,GAAG,CAAC1B,iBAAiB,IAAI,CAAC,IAAID,YAAY;UAC9D,IAAI2B,eAAc,IAAI5B,OAAO,EAAE;YAC7BwB,UAAU,CAACG,IAAI,CAACC,eAAc,EAAEA,eAAc,GAAG,CAAC,CAAC;YACnDH,WAAW,CAACE,IAAI,CAACC,eAAc,GAAG5B,OAAO,EAAE4B,eAAc,GAAG5B,OAAO,CAAC;UACtE,CAAC,MAAM;YACLwB,UAAU,CAACG,IAAI,CAAC3B,OAAO,GAAG,CAAC,CAAC;YAC5ByB,WAAW,CAACE,IAAI,CAAC,CAAC,CAAC;UACrB;QACF;MACF;MAEA,IAAME,UAAU,GAAG,IAAI,CAAC1B,KAAK,CAAC2B,mBAAmB,CAACC,WAAW,CAAC;QAC5DP,UAAU,EAAVA,UAAU;QACVC,WAAW,EAAXA;MACF,CAAC,CAAC;MACF,IAAMb,KAAK,GAAG7B,KAAK,CAAC8B,QAAQ,CAACC,IAAI,CAAC,IAAI,CAACX,KAAK,CAACY,QAAQ,CAAC;MAEtD,OACEhC,KAAA,CAAAiD,aAAA,CAAC9C,YAAY;QACX+C,WAAW,EAAE,KAAM;QACnBtB,QAAQ,EAAE,IAAI,CAACP,SAAU;QACzB8B,KAAK,EAAE,CAACtB,KAAK,CAACT,KAAK,CAAC+B,KAAK,EAAEC,MAAM,CAACC,MAAM,EAAE;UAACC,SAAS,EAAE,CAAC;YAACR,UAAU,EAAVA;UAAU,CAAC;QAAC,CAAC;MAAE,GACtE9C,KAAK,CAACuD,YAAY,CAAC1B,KAAK,EAAE;QACzBsB,KAAK,EAAEC,MAAM,CAACI,IAAI;QAClB5B,QAAQ,EAAE6B;MACZ,CAAC,CACW,CAAC;IAEnB;EAAC;EAAA,OAAApD,sBAAA;AAAA,EA/GkCL,KAAK,CAAC0D,SAAS;AAkHpD,IAAMN,MAAM,GAAGnD,UAAU,CAAC0D,MAAM,CAAC;EAC/BN,MAAM,EAAE;IACNO,MAAM,EAAE;EACV,CAAC;EACDJ,IAAI,EAAE;IACJK,IAAI,EAAE;EACR;AACF,CAAC,CAAC;AAEFC,MAAM,CAACC,OAAO,GAAG1D,sBAAsB"}